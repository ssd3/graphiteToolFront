# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: RootQuery
    mutation: RootMutation
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

type CategoryType {
    categoryid: ID!
    created: DateTime!
    productSet: [ProductType]
    title: String!
    userid: UserType!
}

type CreateCategory {
    category: CategoryType
}

type CreateCredit {
    credit: CreditType
}

type CreateCreditComment {
    creditcomment: CreditCommentType
}

type CreateCreditDetail {
    creditdetail: CreditDetailsType
}

type CreateCreditType {
    credittype: CredittypeType
}

type CreateDebit {
    debit: DebitType
}

type CreateDebitComplex {
    debit: DebitType
    product: ProductType
    productcomment: ProductCommentType
    productdetails: ProductDetailsType
}

type CreateLossType {
    losstype: LosstypeType
}

type CreatePriceType {
    pricetype: PricetypeType
}

type CreateProduct {
    product: ProductType
}

type CreateProductComment {
    productcomment: ProductCommentType
}

type CreateProductDetails {
    productdetails: ProductDetailsType
}

type CreateStatus {
    status: StatusType
}

type CreateWarehouse {
    warehouse: WarehouseType
}

type CreditCommentType {
    comment: String!
    created: DateTime!
    creditcommentid: ID!
    creditid: CreditType!
    userid: UserType!
}

type CreditDetailsType {
    created: DateTime!
    creditdetailsid: ID!
    creditid: CreditType!
    price: Float!
    pricetypeid: PricetypeType!
    productid: ProductType!
    qty: Float!
    userid: UserType!
}

type CreditType implements Node {
    buyerid: Int!
    created: DateTime!
    creditcommentSet: [CreditCommentType]
    creditdetailsSet: [CreditDetailsType]
    creditid: ID!
    credittypeid: CredittypeType!
    fromwarehouseid: Int
    "The ID of the object."
    id: ID!
    received: DateTime
    sent: DateTime
    towarehouseid: Int
    tracknumber: String
    userid: UserType!
}

type CreditTypeConnection {
    edgeCount: Int
    "Contains the nodes in this connection."
    edges: [CreditTypeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalCount: Int
}

"A Relay edge containing a `CreditType` and its cursor."
type CreditTypeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: CreditType
}

type CredittypeType {
    created: DateTime!
    creditSet(after: String, before: String, credittypeid: ID, credittypeid_In: ID, first: Int, last: Int): CreditTypeConnection
    credittypeid: ID!
    description: String
    title: String!
    userid: UserType!
}

type DebitType implements Node {
    created: DateTime!
    debitid: ID!
    discountid: DiscountType!
    "The ID of the object."
    id: ID!
    notes: String
    price: Float!
    pricetypeid: PricetypeType!
    productid: ProductType!
    qty: Float!
    statusid: StatusType!
    tracknumber: String!
    userid: UserType!
    warehouseid: WarehouseType!
}

type DebitTypeConnection {
    edgeCount: Int
    "Contains the nodes in this connection."
    edges: [DebitTypeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalCount: Int
}

"A Relay edge containing a `DebitType` and its cursor."
type DebitTypeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: DebitType
}

type DiscountType {
    created: DateTime!
    debitSet(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    discountid: ID!
    rate: Float!
    title: String!
    units: String!
    userid: UserType!
}

type LosstypeType {
    created: DateTime!
    losstypeid: ID!
    title: String!
    userid: UserType!
}

"Obtain JSON Web Token mutation"
type ObtainJSONWebToken {
    token: String
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PricetypeType {
    created: DateTime!
    creditdetailsSet: [CreditDetailsType]
    debitSet(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    description: String
    pricetypeid: ID!
    ratio: Float!
    title: String!
    userid: UserType!
}

type ProductCommentType {
    comment: String!
    created: DateTime!
    productcommentid: ID!
    productid: ProductType!
    userid: UserType!
}

type ProductConnection {
    "Contains the nodes in this connection."
    edges: [ProductEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalCount: Int
}

type ProductDetailsType {
    created: DateTime!
    height: Float
    lenght: Float
    model: String
    productdetailsid: ID!
    productid: ProductType!
    serialno: String
    url: String
    userid: UserType!
    weight: Float
    width: Float
}

"A Relay edge containing a `Product` and its cursor."
type ProductEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ProductType
}

type ProductType {
    categoryid: CategoryType!
    created: DateTime!
    creditdetailsSet: [CreditDetailsType]
    debitSet(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    description: String
    productcommentSet: [ProductCommentType]
    productdetailsSet: [ProductDetailsType]
    productid: ID!
    title: String!
    userid: UserType!
}

type Refresh {
    payload: GenericScalar
    token: String
}

type RootMutation {
    createCategory(title: String!): CreateCategory
    createCredit(buyerid: Int!, credittypeid: Int!, fromwarehouseid: Int, received: DateTime, sent: DateTime, towarehouseid: Int, tracknumber: String): CreateCredit
    createCreditcomment(comment: String!, creditid: Int!): CreateCreditComment
    createCreditdetail(creditid: Int!, price: Int!, pricetypeid: Int!, productid: Int!, qty: Int!): CreateCreditDetail
    createCredittype(description: String, title: String!): CreateCreditType
    createDebit(discountid: Int!, notes: String, price: Decimal!, pricetypeid: Int!, productid: Int!, qty: Decimal!, statusid: Int!, tracknumber: String!, warehouseid: Int!): CreateDebit
    createDebitcomplex(debitData: DebitInput!, productData: ProductInput!, productcommentData: ProductCommentInput, productdetailsData: ProductDetailsInput): CreateDebitComplex
    createLosstype(title: String!): CreateLossType
    createPricetype(description: String, ratio: Int!, title: String!): CreatePriceType
    createProduct(categoryid: Int!, description: String, title: String!): CreateProduct
    createProductcomment(comment: String, productid: Int!): CreateProductComment
    createProductdetails(height: Decimal, lenght: Decimal, model: String, productid: Int!, serialno: String, url: String, weight: Decimal, width: Decimal): CreateProductDetails
    createStatus(color: String!, title: String!): CreateStatus
    createWarehouse(active: Boolean!, description: String, inField: Boolean!, out: Boolean!, title: String!): CreateWarehouse
    refreshToken(token: String!): Refresh
    "Obtain JSON Web Token mutation"
    tokenAuth(password: String!, username: String!): ObtainJSONWebToken
    updateCategory(categoryid: Int!, title: String!): UpdateCategory
    updateCredit(buyerid: Int!, creditid: Int!, credittypeid: Int!, fromwarehouseid: Int, received: DateTime, sent: DateTime, towarehouseid: Int, tracknumber: String): UpdateCredit
    updateCreditcomment(comment: String, creditcommentid: Int!, creditid: Int!): UpdateCreditComment
    updateCreditdetail(creditdetailid: Int!, creditid: Int, price: Int, pricetypeid: Int, productid: Int, qty: Int): UpdateCreditDetail
    updateCredittype(credittypeid: Int!, description: String, title: String): UpdateCreditType
    updateDebit(debitid: Int!, discountid: Int!, notes: String, price: Decimal!, pricetypeid: Int!, productid: Int!, qty: Decimal!, statusid: Int!, tracknumber: String!, warehouseid: Int!): UpdateDebit
    updateDebitStatusid(debitid: [Int], statusid: Int): UpdateDebitStatusID
    updateDebitcomplex(debitData: DebitUpdateInput!, productData: ProductUpdateInput!, productcommentData: ProductCommentUpdateInput, productdetailsData: ProductDetailsUpdateInput): UpdateDebitComplex
    updateLosstype(losstypeid: Int!, title: String!): UpdateLossType
    updateProduct(categoryid: Int!, description: String, productid: Int!, title: String!): UpdateProduct
    updateProductcomment(comment: String, productcommentid: Int!): UpdateProductComment
    updateProductdetails(height: Decimal, lenght: Decimal, model: String, productdetailsid: Int!, productid: Int!, serialno: String, url: String, weight: Decimal, width: Decimal): UpdateProductDetails
    updateStatus(color: String, statusid: Int!, title: String): UpdateStatus
    updateWarehouse(active: Boolean!, description: String, inField: Boolean!, out: Boolean!, title: String!, warehouseid: Int!): UpdateWarehouse
    verifyToken(token: String!): Verify
}

type RootQuery {
    categories: [CategoryType]
    credit(creditid: Int): CreditType
    creditcomment(creditcommentid: Int): CreditCommentType
    creditcomments: [CreditCommentType]
    creditcommentsBycredit(creditid: Int): [CreditCommentType]
    creditdetail(creditdetailid: Int): CreditDetailsType
    creditdetails(creditid: Int): [CreditDetailsType]
    credits(after: String, before: String, credittypeid: ID, credittypeid_In: ID, first: Int, last: Int): CreditTypeConnection
    credittype(credittypeid: Int): CredittypeType
    credittypes: [CredittypeType]
    debit(debitid: Int): DebitType
    debits(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    debitsBytext(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, searchText: String, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    discount(discountid: Int, title: String, units: String, value: Decimal): DiscountType
    discounts: [DiscountType]
    losstype(losstypeid: Int): LosstypeType
    losstypes: [LosstypeType]
    pricetype(pricetypeid: Int, title: String): PricetypeType
    pricetypes: [PricetypeType]
    product(page: Int, productid: Int, title: String, userid: Int): [ProductType]
    productcomment(productcommentid: Int): ProductCommentType
    productcomments(productid: Int): [ProductCommentType]
    productdetail(productdetailsid: Int): ProductDetailsType
    productdetails(productid: Int): [ProductDetailsType]
    products(after: String, before: String, first: Int, last: Int): ProductConnection
    productsBycategoryTitle(after: String, before: String, categoryTitle: String, first: Int, last: Int): ProductConnection
    productsByuser(after: String, before: String, categoryTitle: String, first: Int, last: Int): ProductConnection
    status(statusid: Int, title: String): StatusType
    statuses(dateFrom: DateTime, dateTo: DateTime, search: String): [StatusType]
    "<graphene.types.scalars.String object at 0x7ff969f75438>"
    user(email: String, userid: Int, username: String): UserType
    users: [UserType]
    warehouse(active: Boolean, inField: Boolean, out: Boolean, title: String, warehouseid: Int): [WarehouseType]
    warehouses(active: Boolean, after: String, before: String, first: Int, inField: Boolean, last: Int, out: Boolean, title: String, title_Icontains: String, title_Istartswith: String): WarehouseTypeConnection
}

type StatusType {
    color: String!
    created: DateTime!
    debitSet(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    statusid: ID!
    title: String!
    userid: UserType!
}

type UpdateCategory {
    category: CategoryType
}

type UpdateCredit {
    credit: CreditType
}

type UpdateCreditComment {
    creditcomment: CreditCommentType
}

type UpdateCreditDetail {
    creditdetail: CreditDetailsType
}

type UpdateCreditType {
    credittype: CredittypeType
}

type UpdateDebit {
    debit: DebitType
}

type UpdateDebitComplex {
    debit: DebitType
    product: ProductType
    productcomment: ProductCommentType
    productdetails: ProductDetailsType
}

type UpdateDebitStatusID {
    debit: [DebitType]
}

type UpdateLossType {
    losstype: LosstypeType
}

type UpdateProduct {
    product: ProductType
}

type UpdateProductComment {
    productcomment: ProductCommentType
}

type UpdateProductDetails {
    productdetails: ProductDetailsType
}

type UpdateStatus {
    status: StatusType
}

type UpdateWarehouse {
    warehouse: WarehouseType
}

type UserType {
    id: ID!
    username: String!
}

type Verify {
    payload: GenericScalar
}

type WarehouseType implements Node {
    active: Boolean!
    created: DateTime!
    debitSet(after: String, before: String, first: Int, last: Int, qty: Float, qty_Gt: Float, qty_Gte: Float, qty_Lt: Float, qty_Lte: Float, tracknumber_Icontains: String, warehouseid: ID, warehouseid_In: ID): DebitTypeConnection
    description: String
    "The ID of the object."
    id: ID!
    inField: Boolean!
    out: Boolean!
    title: String!
    userid: UserType!
    warehouseid: ID!
}

type WarehouseTypeConnection {
    "Contains the nodes in this connection."
    edges: [WarehouseTypeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `WarehouseType` and its cursor."
type WarehouseTypeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: WarehouseType
}

input DebitInput {
    discountid: Int
    notes: String
    price: Decimal
    pricetypeid: Int
    qty: Decimal
    statusid: Int
    tracknumber: String!
    warehouseid: Int!
}

input DebitUpdateInput {
    debitid: Int!
    discountid: Int
    notes: String
    price: Decimal
    pricetypeid: Int
    qty: Decimal
    statusid: Int
    tracknumber: String!
    warehouseid: Int!
}

input ProductCommentInput {
    comment: String
}

input ProductCommentUpdateInput {
    comment: String
    productcomentid: Int!
}

input ProductDetailsInput {
    height: Decimal
    lenght: Decimal
    model: String
    serialno: String
    url: String
    weight: Decimal
    width: Decimal
}

input ProductDetailsUpdateInput {
    height: Decimal
    lenght: Decimal
    model: String
    productdetailsid: Int!
    serialno: String
    url: String
    weight: Decimal
    width: Decimal
}

input ProductInput {
    categoryid: Int!
    description: String
    title: String!
}

input ProductUpdateInput {
    categoryid: Int!
    description: String
    productid: Int!
    title: String!
}


"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"The `Decimal` scalar type represents a python Decimal."
scalar Decimal

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar
